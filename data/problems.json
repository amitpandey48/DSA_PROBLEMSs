[
  {
    "id": 1,
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
    "category": "array",
    "difficulty": "Easy",
    "constraints": [
      "2 ≤ nums.length ≤ 10⁴",
      "-10⁹ ≤ nums[i] ≤ 10⁹",
      "-10⁹ ≤ target ≤ 10⁹",
      "Only one valid answer exists"
    ],
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      }
    ],
    "tags": ["hash-table", "array"]
  },
  {
    "id": 2,
    "title": "Reverse Linked List",
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "category": "linkedlist",
    "difficulty": "Easy",
    "constraints": [
      "The number of nodes in the list is the range [0, 5000]",
      "-5000 ≤ Node.val ≤ 5000"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]",
        "explanation": "The linked list is reversed."
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1]",
        "explanation": "The linked list with two nodes is reversed."
      }
    ],
    "tags": ["linked-list", "recursion"]
  },
  {
    "id": 3,
    "title": "Valid Parentheses",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.",
    "category": "stack",
    "difficulty": "Easy",
    "constraints": [
      "1 ≤ s.length ≤ 10⁴",
      "s consists of parentheses only '()[]{}'."
    ],
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true",
        "explanation": "The string contains valid parentheses."
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": "All brackets are properly matched."
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": "The brackets are not properly matched."
      }
    ],
    "tags": ["stack", "string"]
  },
  {
    "id": 4,
    "title": "Implement Queue using Stacks",
    "description": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).",
    "category": "queue",
    "difficulty": "Easy",
    "constraints": [
      "1 ≤ x ≤ 9",
      "At most 100 calls will be made to push, pop, peek, and empty",
      "All the calls to pop and peek are valid"
    ],
    "examples": [
      {
        "input": "[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
        "output": "[null, null, null, 1, 1, false]",
        "explanation": "MyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false"
      }
    ],
    "tags": ["stack", "design", "queue"]
  },
  {
    "id": 5,
    "title": "Binary Tree Inorder Traversal",
    "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
    "category": "tree",
    "difficulty": "Easy",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100]",
      "-100 ≤ Node.val ≤ 100"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]",
        "explanation": "Inorder traversal visits left subtree, root, then right subtree."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "Empty tree returns empty array."
      }
    ],
    "tags": ["stack", "tree", "depth-first-search"]
  },
  {
    "id": 6,
    "title": "Number of Islands",
    "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.",
    "category": "graph",
    "difficulty": "Medium",
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 ≤ m, n ≤ 300",
      "grid[i][j] is '0' or '1'"
    ],
    "examples": [
      {
        "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
        "output": "1",
        "explanation": "There is one island formed by connected 1's."
      }
    ],
    "tags": ["depth-first-search", "breadth-first-search", "union-find"]
  },
  {
    "id": 7,
    "title": "Contains Duplicate",
    "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
    "category": "hashing",
    "difficulty": "Easy",
    "constraints": [
      "1 ≤ nums.length ≤ 10⁵",
      "-10⁹ ≤ nums[i] ≤ 10⁹"
    ],
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "true",
        "explanation": "The value 1 appears twice in the array."
      },
      {
        "input": "nums = [1,2,3,4]",
        "output": "false",
        "explanation": "All elements are distinct."
      }
    ],
    "tags": ["array", "hash-table", "sorting"]
  },
  {
    "id": 8,
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "category": "array",
    "difficulty": "Medium",
    "constraints": [
      "1 ≤ nums.length ≤ 10⁵",
      "-10⁴ ≤ nums[i] ≤ 10⁴"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "[4,-1,2,1] has the largest sum = 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "Single element array returns that element."
      }
    ],
    "tags": ["array", "divide-and-conquer", "dynamic-programming"]
  },
  {
    "id": 9,
    "title": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.",
    "category": "linkedlist",
    "difficulty": "Easy",
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50]",
      "-100 ≤ Node.val ≤ 100",
      "Both list1 and list2 are sorted in non-decreasing order"
    ],
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "The merged list is sorted."
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": "Both lists are empty."
      }
    ],
    "tags": ["linked-list", "recursion"]
  },
  {
    "id": 10,
    "title": "Min Stack",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class with the specified methods.",
    "category": "stack",
    "difficulty": "Medium",
    "constraints": [
      "-2³¹ ≤ val ≤ 2³¹ - 1",
      "Methods pop, top and getMin operations will always be called on non-empty stacks",
      "At most 3 * 10⁴ calls will be made to push, pop, top, and getMin"
    ],
    "examples": [
      {
        "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]",
        "output": "[null,null,null,null,-3,null,0,-2]",
        "explanation": "MinStack operations maintain minimum efficiently."
      }
    ],
    "tags": ["stack", "design"]
  },
  {
    "id": 11,
    "title": "Binary Tree Level Order Traversal",
    "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "category": "tree",
    "difficulty": "Medium",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000]",
      "-1000 ≤ Node.val ≤ 1000"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[9,20],[15,7]]",
        "explanation": "Level by level traversal of the tree."
      }
    ],
    "tags": ["tree", "breadth-first-search"]
  },
  {
    "id": 12,
    "title": "Course Schedule",
    "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. Return true if you can finish all courses. Otherwise, return false.",
    "category": "graph",
    "difficulty": "Medium",
    "constraints": [
      "1 ≤ numCourses ≤ 2000",
      "0 ≤ prerequisites.length ≤ 5000",
      "prerequisites[i].length == 2",
      "0 ≤ ai, bi < numCourses",
      "All the pairs prerequisites[i] are unique"
    ],
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1,0]]",
        "output": "true",
        "explanation": "There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "false",
        "explanation": "There are cycles in the prerequisites, making it impossible to finish all courses."
      }
    ],
    "tags": ["depth-first-search", "breadth-first-search", "graph", "topological-sort"]
  },
  {
    "id": 13,
    "title": "Group Anagrams",
    "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "category": "hashing",
    "difficulty": "Medium",
    "constraints": [
      "1 ≤ strs.length ≤ 10⁴",
      "0 ≤ strs[i].length ≤ 100",
      "strs[i] consists of lowercase English letters"
    ],
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": "Anagrams are grouped together."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "Empty string forms its own group."
      }
    ],
    "tags": ["array", "hash-table", "string", "sorting"]
  },
  {
    "id": 14,
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "category": "array",
    "difficulty": "Easy",
    "constraints": [
      "1 ≤ prices.length ≤ 10⁵",
      "0 ≤ prices[i] ≤ 10⁴"
    ],
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "In this case, no transaction is done, i.e. max profit = 0."
      }
    ],
    "tags": ["array", "dynamic-programming"]
  },
  {
    "id": 15,
    "title": "Linked List Cycle",
    "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer.",
    "category": "linkedlist",
    "difficulty": "Easy",
    "constraints": [
      "The number of the nodes in the list is in the range [0, 10⁴]",
      "-10⁵ ≤ Node.val ≤ 10⁵",
      "pos is -1 or a valid index in the linked-list"
    ],
    "examples": [
      {
        "input": "head = [3,2,0,-4], pos = 1",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "There is no cycle in the linked list."
      }
    ],
    "tags": ["hash-table", "linked-list", "two-pointers"]
  },
  {
    "id": 16,
    "title": "Remove Duplicates from Sorted Array",
    "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.",
    "category": "array",
    "difficulty": "Easy",
    "constraints": [
      "1 ≤ nums.length ≤ 3 * 10⁴",
      "-100 ≤ nums[i] ≤ 100",
      "nums is sorted in non-decreasing order"
    ],
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "2, nums = [1,2,_]",
        "explanation": "Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively."
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
        "explanation": "Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively."
      }
    ],
    "tags": ["array", "two-pointers"]
  },
  {
    "id": 17,
    "title": "Rotate Array",
    "description": "Given an array, rotate the array to the right by k steps, where k is non-negative.",
    "category": "array",
    "difficulty": "Medium",
    "constraints": [
      "1 ≤ nums.length ≤ 10⁵",
      "-2³¹ ≤ nums[i] ≤ 2³¹ - 1",
      "0 ≤ k ≤ 10⁵"
    ],
    "examples": [
      {
        "input": "nums = [1,2,3,4,5,6,7], k = 3",
        "output": "[5,6,7,1,2,3,4]",
        "explanation": "Rotate 1 steps to the right: [7,1,2,3,4,5,6]\nRotate 2 steps to the right: [6,7,1,2,3,4,5]\nRotate 3 steps to the right: [5,6,7,1,2,3,4]"
      },
      {
        "input": "nums = [-1,-100,3,99], k = 2",
        "output": "[3,99,-1,-100]",
        "explanation": "Rotate 1 steps to the right: [99,-1,-100,3]\nRotate 2 steps to the right: [3,99,-1,-100]"
      }
    ],
    "tags": ["array", "math", "two-pointers"]
  },
  {
    "id": 18,
    "title": "Merge Sorted Array",
    "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order.",
    "category": "array",
    "difficulty": "Easy",
    "constraints": [
      "nums1.length == m + n",
      "nums2.length == n",
      "0 ≤ m, n ≤ 200",
      "1 ≤ m + n ≤ 200",
      "-10⁹ ≤ nums1[i], nums2[j] ≤ 10⁹"
    ],
    "examples": [
      {
        "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
        "output": "[1,2,2,3,5,6]",
        "explanation": "The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "We merge [1] and []. The result is [1]."
      }
    ],
    "tags": ["array", "two-pointers", "sorting"]
  },
  {
    "id": 19,
    "title": "Min Stack",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class with the specified methods.",
    "category": "stack",
    "difficulty": "Medium",
    "constraints": [
      "-2³¹ ≤ val ≤ 2³¹ - 1",
      "Methods pop, top and getMin operations will always be called on non-empty stacks",
      "At most 3 * 10⁴ calls will be made to push, pop, top, and getMin"
    ],
    "examples": [
      {
        "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]",
        "output": "[null,null,null,null,-3,null,0,-2]",
        "explanation": "MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2"
      }
    ],
    "tags": ["stack", "design"]
  },
  {
    "id": 20,
    "title": "Evaluate Reverse Polish Notation",
    "description": "Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, and /. Each operand may be an integer or another expression.",
    "category": "stack",
    "difficulty": "Medium",
    "constraints": [
      "1 ≤ tokens.length ≤ 10⁴",
      "tokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200]"
    ],
    "examples": [
      {
        "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
        "output": "9",
        "explanation": "((2 + 1) * 3) = 9"
      },
      {
        "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
        "output": "6",
        "explanation": "(4 + (13 / 5)) = 6"
      }
    ],
    "tags": ["stack", "array", "math"]
  },
  {
    "id": 21,
    "title": "Binary Tree Preorder Traversal",
    "description": "Given the root of a binary tree, return the preorder traversal of its nodes' values.",
    "category": "tree",
    "difficulty": "Easy",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100]",
      "-100 ≤ Node.val ≤ 100"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,2,3]",
        "explanation": "Preorder traversal visits root, left subtree, then right subtree."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "Empty tree returns empty array."
      }
    ],
    "tags": ["stack", "tree", "depth-first-search"]
  },
  {
    "id": 22,
    "title": "Binary Tree Postorder Traversal",
    "description": "Given the root of a binary tree, return the postorder traversal of its nodes' values.",
    "category": "tree",
    "difficulty": "Easy",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100]",
      "-100 ≤ Node.val ≤ 100"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[3,2,1]",
        "explanation": "Postorder traversal visits left subtree, right subtree, then root."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "Empty tree returns empty array."
      }
    ],
    "tags": ["stack", "tree", "depth-first-search"]
  },
  {
    "id": 23,
    "title": "Maximum Depth of Binary Tree",
    "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "category": "tree",
    "difficulty": "Easy",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10⁴]",
      "-100 ≤ Node.val ≤ 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3",
        "explanation": "The maximum depth is 3, which is the path from root to the farthest leaf node."
      },
      {
        "input": "root = [1,null,2]",
        "output": "2",
        "explanation": "The maximum depth is 2."
      }
    ],
    "tags": ["tree", "depth-first-search", "breadth-first-search"]
  },
  {
    "id": 24,
    "title": "Symmetric Tree",
    "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
    "category": "tree",
    "difficulty": "Easy",
    "constraints": [
      "The number of nodes in the tree is in the range [1, 1000]",
      "-100 ≤ Node.val ≤ 100"
    ],
    "examples": [
      {
        "input": "root = [1,2,2,3,4,4,3]",
        "output": "true",
        "explanation": "The tree is symmetric around its center."
      },
      {
        "input": "root = [1,2,2,null,3,null,3]",
        "output": "false",
        "explanation": "The tree is not symmetric."
      }
    ],
    "tags": ["tree", "depth-first-search", "breadth-first-search"]
  },
  {
    "id": 25,
    "title": "Path Sum",
    "description": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.",
    "category": "tree",
    "difficulty": "Easy",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 5000]",
      "-1000 ≤ Node.val ≤ 1000",
      "-1000 ≤ targetSum ≤ 1000"
    ],
    "examples": [
      {
        "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
        "output": "true",
        "explanation": "The path 5→4→11→2 has sum 22."
      },
      {
        "input": "root = [1,2,3], targetSum = 5",
        "output": "false",
        "explanation": "There is no root-to-leaf path with sum 5."
      }
    ],
    "tags": ["tree", "depth-first-search", "breadth-first-search"]
  },
  {
    "id": 26,
    "title": "Breadth First Search",
    "description": "Implement a breadth-first search algorithm to traverse a graph and find the shortest path between two nodes.",
    "category": "graph",
    "difficulty": "Medium",
    "constraints": [
      "1 ≤ number of nodes ≤ 10⁴",
      "0 ≤ number of edges ≤ 10⁴",
      "All nodes are reachable from the start node"
    ],
    "examples": [
      {
        "input": "graph = [[1,2],[0,3],[0,3],[1,2]], start = 0, end = 3",
        "output": "[0,1,3]",
        "explanation": "The shortest path from node 0 to node 3 is [0,1,3]."
      },
      {
        "input": "graph = [[1,2],[0,2],[0,1]], start = 0, end = 2",
        "output": "[0,2]",
        "explanation": "The shortest path from node 0 to node 2 is [0,2]."
      }
    ],
    "tags": ["breadth-first-search", "graph", "shortest-path"]
  },
  {
    "id": 27,
    "title": "Depth First Search",
    "description": "Implement a depth-first search algorithm to traverse a graph and find all reachable nodes from a starting node.",
    "category": "graph",
    "difficulty": "Medium",
    "constraints": [
      "1 ≤ number of nodes ≤ 10⁴",
      "0 ≤ number of edges ≤ 10⁴",
      "All nodes are reachable from the start node"
    ],
    "examples": [
      {
        "input": "graph = [[1,2],[0,3],[0,3],[1,2]], start = 0",
        "output": "[0,1,3,2]",
        "explanation": "DFS traversal starting from node 0 visits all nodes."
      },
      {
        "input": "graph = [[1,2],[0,2],[0,1]], start = 0",
        "output": "[0,1,2]",
        "explanation": "DFS traversal starting from node 0 visits all nodes."
      }
    ],
    "tags": ["depth-first-search", "graph", "traversal"]
  },
  {
    "id": 28,
    "title": "Word Ladder",
    "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord → s₁ → s₂ → ... → sₖ such that: Every adjacent pair of words differs by a single letter, and every sᵢ for 1 ≤ i ≤ k is in wordList.",
    "category": "graph",
    "difficulty": "Hard",
    "constraints": [
      "1 ≤ beginWord.length ≤ 10",
      "endWord.length == beginWord.length",
      "1 ≤ wordList.length ≤ 5000",
      "wordList[i].length == beginWord.length",
      "beginWord, endWord, and wordList[i] consist of lowercase English letters",
      "beginWord != endWord",
      "All the words in wordList are unique"
    ],
    "examples": [
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
        "output": "5",
        "explanation": "One shortest transformation sequence is \"hit\" → \"hot\" → \"dot\" → \"dog\" → \"cog\", which is 5 words long."
      },
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
        "output": "0",
        "explanation": "The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence."
      }
    ],
    "tags": ["breadth-first-search", "hash-table", "string"]
  },
  {
    "id": 29,
    "title": "LRU Cache",
    "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class with get and put operations.",
    "category": "hashing",
    "difficulty": "Medium",
    "constraints": [
      "1 ≤ capacity ≤ 3000",
      "0 ≤ key ≤ 10⁴",
      "0 ≤ value ≤ 10⁵",
      "At most 2 * 10⁵ calls will be made to get and put"
    ],
    "examples": [
      {
        "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
        "output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
        "explanation": "LRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
      }
    ],
    "tags": ["hash-table", "linked-list", "design", "doubly-linked-list"]
  },
  {
    "id": 30,
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "category": "hashing",
    "difficulty": "Medium",
    "constraints": [
      "0 ≤ s.length ≤ 5 * 10⁴",
      "s consists of English letters, digits, symbols and spaces"
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is \"wke\", with the length of 3."
      }
    ],
    "tags": ["hash-table", "string", "sliding-window"]
  }
]
